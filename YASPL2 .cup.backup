

import java_cup.Lexer;
import java_cup.parser;
import java_cup.runtime.*;
import java_cup.runtime.Scanner;
import com.scalified.tree.*;
import com.scalified.tree.multinode.*;
import java.util.*;

import Visitor.*;


parser code {:
    
    Scanner s;
    void parser(Scanner s, String k){ this.s=s; }

   public VisitableNode<String> makeNode(String name, VisitableNode<String> ... childrens){

           VisitableNode<String> toReturn = new VisitableNode<String>(name);

           for(int i = 0; i < childrens.length; i ++){
               toReturn.add(childrens[i]);
           }

           return toReturn;
       }

     public VisitableNode<String> makeNode(String name, ArrayList<VisitableNode<String>> childrens){

               VisitableNode<String> toReturn = new VisitableNode<String>(name);

                for (VisitableNode<String> node : childrens)
                   toReturn.add(node);

               return toReturn;
           }

            public void syntax_error(Symbol cur_token){
            
            int row = cur_token.left+1;
            int col = cur_token.right;
           
             }


:}

init with {:   :};
scan with {: return s.next_token(); :};


terminal           HEAD, START, SEMI, COMMA, DEF;
terminal           NAME;
terminal           LPAR, RPAR, COLON, LGPAR, RGPAR;
terminal           INT_CONST, DOUBLE_CONST, STRING_CONST;
terminal           PLUS, MINUS, TIMES, DIV;
terminal           INT, BOOL, DOUBLE;
terminal           READ, WRITE;
terminal           TRUE, FALSE;
terminal           ASSIGN;
terminal           IF, THEN, WHILE, DO, ELSE;
terminal           GT, GE, LT, LE, EQ, NOT, AND, OR, UMINUS;


non terminal            Programma, Decls, Statments, Var_decl, Type, Vars, Types, Def_decl, Var_decls, Par_decls, Body, Comp_stat, Stat, Simple_stat, Out_values, Exprs, Expr, Arith_op, Bool_expr, Bool_op, Rel_op;


precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left ASSIGN, READ, WRITE;
precedence left ELSE;
precedence left GT, LT; 
precedence left EQ, GE, LE;
precedence left AND, OR;
precedence left COMMA;
precedence left UMINUS;


Programma     ::= HEAD:h Decls:ds START Statments:sts {: VisitableNode<String> Program_node = new VisitableNode<String>("PROGRAM_NODE",ds,sts);
														 RESULT = Program_node;
														 NodeVisitor visitor = new NodeVisitor();
                                        				 visitor.visit(RESULT);
                                        				 visitor.saveFileXML();
                                        				 

														:};

Decls         ::= Var_decl:v Decls:ds {: ArrayList<VisitableNode<String>> decls_list = new ArrayList<VisitableNode<String>>();  
												decls_list.add(v);
												decls_list.addAll(ds);
												RESULT = decls_list;
										:}
					| Def_decl:d Decls:ds {: ArrayList<VisitableNode<String>> decls_list = new ArrayList<VisitableNode<String>>();  
												decls_list.add(v);
												decls_list.addAll(ds);
												RESULT = decls_list;
										:}
					|  ;

Statments     ::= Stat:s Statments:sts {: RESULT = sts.add(s); :}
					| Stat:s {: ArrayList<VisitableNode<String>> Stat_list = new ArrayList<VisitableNode<String>>(); 
								Stat_list.add((VisitableNode<String>)s);
								RESULT = Stat_list;  :};

Var_decl      ::= Type:t Vars:vs SEMI {: Vector<String> v = (Vector<String>)vs;
											ArrayList<VisitableNode<String>> childrens = new ArrayList<VisitableNode<String>>(v.size());
											VisitableNode<String> root = makeNode("VAR_DECL_NODE", makeNode(t.toString()));
												for (int i=0;i<v.size(); i++) {
													childrens[i].setData("VAR_NODE");
													childrens[i].add(new VisitableNode<String>("ID_NODE",vs[i]));
													if(i!=v.size())
														childrens[i].add(childrens[i+1]);
												}		
												root.add(childrens[0]);
												RESULT = root;
												
										:};

Type          ::= INT:i {: RESULT="Integer"; :}|BOOL:b {: RESULT="Boolean"; :}|DOUBLE:d {: RESULT="Double"; :};

Vars          ::= NAME:n COMMA Vars:vs {: Vector<String> x = new Vector<String>((Vector<String>)vs);
    									RESULT = x.add(n.toString());  :}
					| NAME:n {:  Vector<String> x = new Vector<String>(); x.add(n.toString());  RESULT = x; :};

Types         ::= Type:t COMMA:c Types:ts {: Vector<String> x = new Vector<String>((Vector<String>)ts);
    									RESULT = x.add(t.toString()); :}
					| Type:t {:  Vector<String> x = new Vector<String>(); x.add(t.toString()); RESULT = x; :};

Def_decl      ::= DEF:d NAME:n LPAR:lp Var_decls:vds RPAR:rp COLON:c Par_decls:pds Body:b {:  VisitableNode<String> ProcDecl_node = new VisitableNode<String>("PROC_DECL_NODE",vds,pds); 
																							  ProcDecl_node.add(new VisitableNode<String>("ID_NODE",n));
																							  ProcDecl_node.add(b);
																							  RESULT = ProcDecl_node;

																						:};

Var_decls     ::= Var_decl:vd Var_decls:vds {: 	ArrayList<VisitableNode<String>> var_decl_list = new ArrayList<VisitableNode<String>>();  
												var_decl_list.add(vd);
												var_decl_list.addAll(vds);
												RESULT = var_decl_list;
											:}
					|;

Par_decls     ::= Var_decl:vd Par_decls:pds {:	ArrayList<VisitableNode<String>> var_decl_list = new ArrayList<VisitableNode<String>>();  
												var_decl_list.add(vd);
												var_decl_list.addAll(pds);
												RESULT = var_decl_list;	:}
					| Var_decl:vd {: ArrayList<VisitableNode<String>> par_decl_list = new ArrayList<VisitableNode<String>>();  
									 par_decl_list.add(vd);
									 RESULT = par_decl_list; :};

Body          ::= LGPAR:lgp Var_decls:vds Statments:sts RGPAR:rgp SEMI:s {: RESULT = new VisitableNode<String>("BODY_NODE",vds,sts);  :};

Comp_stat     ::= LGPAR:lgp Statments:sts RGPAR:rgp {: RESULT = sts; :};

Stat          ::= Comp_stat:cs {: RESULT = cs; :}
					| Simple_stat:ss {: RESULT = ss; :};

Simple_stat   ::= Vars:v READ:r Types:t SEMI:s {: Vector<String> vv = (Vector<String>)v;
												  ArrayList<VisitableNode<String>> id_list = new ArrayList<VisitableNode<String>>();
												  ArrayList<VisitableNode<String>> type_list = new ArrayList<VisitableNode<String>>();
												  for(int i = 0; i<vv.size(); i++){
												  	id_list.add( new VisitableNode("ID_NODE",v[i]));
												  	type_list.add( new VisitableNode("ID_NODE",t[i]));
												  }
												VisitableNode<String> Read_OP_node = new VisitableNode<String>("READ_OP_NODE",id_list,type_list);  
												RESULT = Read_OP_node;
												:}
					| Out_values:ov WRITE:w SEMI:s {: VisitableNode<String> Write_OP_node = new VisitableNode<String>("WRITE_OP_NODE",ov);  
														RESULT = Write_OP_node;
													:}
													
					| NAME:n ASSIGN:a Expr:e SEMI:s {: VisitableNode<String> id_node = new VisitableNode<String>("ID_NODE",n);
														VisitableNode<String> ee = (VisitableNode<String>)e;  
														RESULT = makeNode("ASSIGN_NODE",id_node, ee);
														
													:}
					| NAME:n LPAR:lp Exprs:es COLON:c Vars:vs RPAR:rp SEMI:s {:   Vector<String> vv = (Vector<String>)v;
																				  ArrayList<VisitableNode<String>> id_list = new ArrayList<VisitableNode<String>>();
												  								  for(int i = 0; i<vv.size(); i++){
												  	 								id_list.add( new VisitableNode("ID_NODE",vs[i]));
												  										}
																				  VisitableNode<String> CALL_OP_node = new VisitableNode<String>("CALL_OP_NODE",id_list,es);  
																				  CALL_OP_node.add(	new VisitableNode<String>("ID_NODE",n));
																				  RESULT = CALL_OP_node;
																			
																				:}
					| IF:i LPAR:lp Bool_expr:be RPAR:rp THEN:t Comp_stat:cs1 ELSE:e Comp_stat:cs2 SEMI:s {:	RESULT = makeNode("IFTHENELSE_NODE",(VisitableNode<String>)be,(VisitableNode<String>)cs1,(VisitableNode<String>)cs2); :}
					| IF:i LPAR:lp Bool_expr:be RPAR:rp THEN:t Comp_stat:cs SEMI:s {: RESULT = makeNode("IFTHEN_NODE",(VisitableNode<String>)be,(VisitableNode<String>)cs); :}
					| WHILE:w LPAR:lp Bool_expr:be RPAR:rp DO:d Comp_stat:cs SEMI:s {: RESULT = makeNode("WHILE_NODE",(VisitableNode<String>)be,(VisitableNode<String>)cs); :};

Out_values    ::= Expr:e COMMA:c Out_values:ovs {: RESULT = ovs.add(e); :}
					| STRING_CONST:sc COMMA:c Out_values:ovs {: RESULT = ovs.add(makeNode(sc.toString()));  :}
					| Expr:e {: ArrayList<VisitableNode<String>> outvalues_list = new ArrayList<VisitableNode<String>>(); 
								outvalues_list.add((VisitableNode<String>)e);
								RESULT = outvalues_list; :}
					| STRING_CONST:sc {: ArrayList<VisitableNode<String>> outvalues_list = new ArrayList<VisitableNode<String>>(); 
										outvalues_list.add(makeNode(sc.toString()));
										RESULT = outvalues_list; :};

Exprs         ::= Expr:e COMMA:c Exprs:es {:  RESULT = es.add(e); :}
					| Expr:e {: ArrayList<VisitableNode<String>> Exprs_list = new ArrayList<VisitableNode<String>>(); 
								Exprs_list.add((VisitableNode<String>)e);
								RESULT = Exprs_list; :};

Expr          ::= INT_CONST:ic {: RESULT = makeNode("INT_CONST",ic); :}
					| DOUBLE_CONST:dc {: RESULT = makeNode("DOUBLE_CONST",dc); :}
					| Expr:e1 Arith_op:ao Expr:e2 {: 
													    switch (ao.toString()) {
																case "+":
																	 RESULT = makeNode("ADD_NODE", e1, e2);
																	break;
																
																case "-":
																	 RESULT = makeNode("MINUS_NODE", e1, e2);
																	break;
																
																case "*":
																	 RESULT = makeNode("MUL_NODE", e1, e2);
																	break;
																
																case "/":
																	 RESULT = makeNode("DIV_NODE", e1, e2);
																	break;
														
																default:
																	 
																	break;
																}
													:}
													
					| NAME:n {: RESULT = makeNode("ID_NODE",n); :}
					| UMINUS:u Expr:e {: RESULT = makeNode("UMINUS_NODE", e); :} %prec UMINUS
					| LPAR:lp Expr:e RPAR:rp {: RESULT = e; :};

Arith_op      ::= PLUS {: RESULT = "+"; :}
					 | MINUS {: RESULT = "-"; :}
					 | TIMES {: RESULT = "*"; :}
					 | DIV {: RESULT = "/"; :};

Bool_expr     ::= Bool_expr:be1 Bool_op:bo Bool_expr:be2 {: if(bo=="and")
																RESULT = makeNode("AND_NODE", be1,be2);
															else 
																RESULT = makeNode("OR_NODE", be1,be2);  :}
					| NOT:n Bool_expr:be {: RESULT = makeNode("NOT_NODE", be); :}
					| Expr:e1 Rel_op:ro Expr:e2 {:  switch (ro.toString()) {
																case ">":
																	 RESULT = makeNode("GT_NODE", e1, e2);
																	 break;
																case "<":
																	 RESULT = makeNode("LT_NODE", e1, e2);
																	 break;
																
																case ">=":
																	 RESULT = makeNode("GE_NODE", e1, e2);
																	 break;
																
																case "<=":
																	 RESULT = makeNode("LE_NODE", e1, e2);
																	 break;
																	
																case "==":
																	 RESULT = makeNode("EQ_NODE", e1, e2);
																	 break;
																	 
																default:
																	 
																	break;
																}  
																:}
					| LPAR:lp Bool_expr:be RPAR:rp {: RESULT = be; :}
					| TRUE {: RESULT = makeNode("TRUE"); :}
					| FALSE {: RESULT = makeNode("FALSE"); :};

Bool_op       ::= AND {: RESULT = "and"; :}
					| OR {: RESULT = "or"; :};

Rel_op        ::= GT {: RESULT = ">"; :}
					| GE {: RESULT = ">="; :}
					| LT {: RESULT = "<"; :}
					| LE {: RESULT = "<="; :}
					| EQ {: RESULT = "=="; :};
